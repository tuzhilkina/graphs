// Лекция 9
// КУЧИ
//1. Выбор и удаление минимального элемента
//2. Добавление элемента
//3. Удаление элемента
//4. Увеличение элемента
//5. Уменьшение элемента
//6. Окучивание(heapify) – преобразование неупорядоченного массива данных в кучу.

//Куча - «ровное» бинарноу дерево, выполняется «соотношение порядка».
// уровни заполняются элементами последовательно сверху вниз и слева направо
// k - вершина, i, j - потомки
// Vk < Vi && Vk < Vj

// Минимальный элемент кучи находится в ее корне.


#include <iostream>
#include <vector>
#include <iomanip>
#include <math.h>
using namespace std;

class Heap {
public:
	Heap() = default;
	~Heap() = default;
	Heap(const Heap&) = default;
	Heap& operator=(const Heap&) = default;

	// получение минимального элемента, т.е. вершины кучи
	int get();
	// вставка элемента в кучу
	void insert(const int& v);
	// удаление элемента pos
	void remove(const int& pos);
	// превращение массива в кучу
	void heapify();
	void print();

private:
	// восстановление кучи после увеличения элемента pos
	void out_remont(const int& pos);
	// восстановление кучи после уменьшения элемента pos
	void in_remont(const int& pos);
	// данные кучи. k - предок, 2k+1, 2k+2 - потомки
	vector<int> A;
	// размер кучи
	int n{ 0 };
};

// восстановление кучи после увеличения элемента pos
void Heap::out_remont(const int& pos) {
	// цикл от корня к листьям, пока у вершины есть потомки
	for (int v(pos); v < (n - 1) / 2; v = 2 * v + 1) {
		int child1 = 2 * v + 1;
		int child2 = 2 * v + 2;
		// если существует второй потомок и он меньше первого
		if (child2 < n && A[child2] < A[child1])
			child1 = child2; // child1 теперь хранит меньшего из 2 потомков
		if (A[v] < A[child1]) break; // сообщение порядка выполнено
		// соотношение порядка не выполнено.
		swap(A[v], A[child1]); // устанавливаем соотношение порядка. Потомок и родитель меняются местами
		// и на следующей итерации проверяем, не нарушилось ли соотношение 
		// для потомков вершины с увеличившимся значением
	}
}

// восстановление кучи после уменьшения элемента pos
void Heap::in_remont(const int& pos) {
	// цикл от листьев к корню
	for (int v(pos); v > 0; v = (v - 1) / 2) {
		int parent((v - 1) / 2);
		if (A[parent] < A[v]) break; // соотношение порядка выполнено
		// соотношение порядка не выполнено, восстанавливаем его
		swap(A[parent], A[v]);
		// и проверяем, не нарушилось ли оно после перестановки, в следующей итерации
	}
}

// получение минимального элемента, т.е. вершины кучи
int Heap::get() {
	int min(A[0]); // сохраняем значение минимального элемента - вершины кучи
	A[0] = A[n - 1]; // последний элемент становится корнем
	A.pop_back(); // размер кучи уменьшился
	out_remont(0); // восстанавливаем кучу после увеличения элемента 0
	return min;
}

// вставка элемента в кучу
void Heap::insert(const int& v) {
	A.push_back(v); // вставляем элемент в конец кучи
	++n;
	in_remont(n - 1); // восстанавливаем кучу после вставки, возможно, маленького листа
}

// удаление элемента pos
void Heap::remove(const int& pos) {
	int value(A[pos]);
	A[pos] = A[A.size() - 1]; // последний элемент ставим на место удаляемого
	A.pop_back(); // удаляем последний элемент
	// восстанавливаем кучу после вставки последнего элемента в зависимости разницы между ним и удаляемым элементом
	(A[pos] > value) ? (out_remont(pos)) : (in_remont(pos));
}

// превращение массива в кучу
void Heap::heapify() {
	// начинаем от последнего поддерева "вершина - 2 потомка" и до корневого поддерева
	// т.к. у листьев нет потомков - соотношение порядка выполняется
	for (int v((n - 1) / 2); v >= 0; v--)
		out_remont(v); // восстанавливаем соотношение порядка
}

void Heap::print() {
	for (const auto& it : A)
		cout << it << " ";
	cout << "\n";
}

int main() {
	Heap obj{ Heap() };
	obj.insert(3);
	obj.insert(5);
	obj.insert(10);
	obj.insert(7);
	obj.insert(2);
	obj.insert(8);	
	obj.insert(14);
	obj.insert(11);
	obj.insert(20);
	obj.insert(5);
	obj.insert(11);
	obj.insert(7);
	obj.insert(24);
	obj.insert(19);
	obj.insert(1);
	obj.print();
};