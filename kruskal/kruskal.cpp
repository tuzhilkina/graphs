// Лекция 4
// ЗАДАЧА ПОСТРОЕНИЯ КРАТЧАЙШЕГО СВЯЗЫВАЮЩЕГО ДЕРЕВА
// Алгоритм Краскала

#include <iostream>
#include <array>
#include <string>
#include <iomanip>

class Graph {
public:
    Graph();
    ~Graph() = default;
    Graph(const Graph&) = default;
    Graph& operator=(const Graph&) = default;
    void print() const;

private:
    void sort();
    void surface(int i, int k);
    int find(const int& i) const;
    void unite(const int& mi, const int& mj);

    static const size_t m{ 13 };
    static const size_t n{ 7 };
    // Начало ребра
    std::array<int, m> I{ 0, 0, 0, 1, 1, 1, 2, 4, 5, 3, 6, 4, 6 };
    // Конец ребра
    std::array<int, m> J{ 4, 1, 2, 4, 2, 3, 3, 3, 2, 5, 3, 6, 5 };
    // Длина ребра
    std::array<int, m> C{ 9, 6, 9, 4, 8, 6, 7, 3, 5, 2, 4, 3, 4 };
    // Включенные в связывающее дерево ребра
    std::array<int, n - 1> K{ 0 }; 
    // Номер подмножества, в которое входит вершина i
    std::array<int, n> M{ 0 };
};

// Преобразует почти упорядоченное дерево в упорядоченноеэ
// упорядоченное дерево - значение в его вершине не меньше, чем значения в дочерних вершинах
// частично упорядоченное дерево - упорядоченность выполняется для каждой из вершин, но не для корня
void Graph::surface(int root, int max) {
    // root - корень поддерева
    // max - элемент массива с максимальным индексом, который принадлежит дереву, то есть конец дерева
    int child(-1); // большая из вершин поддерева
    // сохранение значения корня поддерева
    int i_r(I[root]), j_r(J[root]), c_r(C[root]);
    // пока мы находимся в пределах поддерева
    while (2 * root <= max) {
        // если левая вершина совпадает с максимальным элементом поддерева
        if (2 * root == max)
            child = 2 * root; // то это нужная вершина
        else
            // выбираем большую вершину. При равенстве выбирается правая
            (C[2 * root] > C[2 * root + 1]) ? (child = 2 * root) : (child = 2 * root + 1);
        
        // если вершина больше корня
        if (C[child] > c_r) {
            // большая вершина становится корнем
            I[root] = I[child];
            J[root] = J[child];
            C[root] = C[child];
            root = child;
        }
        // в вершине находится больший элемент
        else break;
    }
    // перенос корня всего поддерева на место, где находилась большая вершина
    I[root] = i_r;
    J[root] = j_r;
    C[root] = c_r;
}

void Graph::sort() {
    int last = m - 1; // номер последнего элемента в массиве
    // идем по "уровням" - от нижнего к верхнему
    // на нижнем уровне поддерево - корень + 2 вершины
    // в корне оказывается большее из 3 чисел
    // на верхних уровнях нет необхомости просматривать все многоуровневое поддерево целиком:
    // большие элементы нижних уровней располагаются в вершинах, исходящих из корня
    // в результате получаем упорядоченное дерево
    for (int i(last / 2); i > 0; --i)
        surface(i, last);

    // рассматриваем дерево, корень которого - 0
    // а конец дерева - последний элемент перед упорядоченной областью
    for (int i(last); i > 0; --i) {
        // в результате образуется упорядоченное дерево
        // в вершине упорядоченного дерева находиться больший элемент
        surface(0, i);
        // больший элемент переносится в конец дерева
        // конец дерева теперь принадлежит упорядоченной области
        // дерево становится частично упорядоченным
        std::swap(I[i], I[0]);
        std::swap(J[i], J[0]);
        std::swap(C[i], C[0]);
    }
}

// возвращает номер подмножества, в которое входит вершина i
int Graph::find(const int& i) const {
    return M[i];
}

// объединяет подмножества i и j в подмножество j
void Graph::unite(const int& mi, const int& mj) {
    for (auto& it : M)
        if (it == mi)
            it = mj;
}

Graph::Graph() {
    sort();
    // Каждая из вершин образует отдельное подмножество
    for (int v(0); v < n; ++v)
        M[v] = v;
    // Указатель на первую свободную позицию в массиве K
    int pos(0);

    // Просмотр ребер графа по возрастанию длины
    // Заканчиваем просмотр после исчерпания дуг графа
    // и когда полностью сформируется дерево
    for (int e(0); e < m && pos < n - 1; ++e) {
        int i(I[e]);
        int j(J[e]);
        int mi = find(i);
        int mj = find(j);
        // Если i и j находятся в разных подмножествах, т.е. не образуется цикл
        if (mi != mj) {
            K[pos] = e; // Добавляем ребро e в дерево K
            ++pos;
            unite(mi, mj);
        }
    }

    print();
}

void Graph::print() const {
    std::cout << "   ";
    for (int i(0); i < m; ++i)
        std::cout << std::setw(2) << i << " ";
    std::cout << "\nI: ";
    for (const auto& it : I)
        std::cout << std::setw(2) << it << " ";
    std::cout << "\nJ: ";
    for (const auto& it : J)
        std::cout << std::setw(2) << it << " ";
    std::cout << "\nC: ";
    for (const auto& it : C)
        std::cout << std::setw(2) << it << " ";
    std::cout << "\nK: ";
    for (const auto& it : K)
        std::cout << std::setw(2) << it << " ";
    std::cout << "\n";
}


int main() {
    Graph obj{ Graph() };
}