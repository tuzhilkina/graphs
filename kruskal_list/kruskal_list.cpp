// Лекция 4
// ЗАДАЧА ПОСТРОЕНИЯ КРАТЧАЙШЕГО СВЯЗЫВАЮЩЕГО ДЕРЕВА
// Алгоритм Краскала
// Реализация логарифмического алгоритма

#include <iostream>
#include <array>
#include <string>
#include <iomanip>

class Graph {
public:
    Graph();
    ~Graph() = default;
    Graph(const Graph&) = default;
    Graph& operator=(const Graph&) = default;
    void print() const;

private:
    // Сортировка ребер по возрастанию длины
    void sort();
    void surface(int i, int k);
    // Определение подмножества, к которому принаджедит вершина i
    int find(const int& i) const;
    // Объединение подмножеств
    void unite(const int& mi, const int& mj);

    static const int m{ 13 };
    static const int n{ 7 };
    // Начало ребра
    std::array<int, m> I{ 0, 0, 0, 1, 1, 1, 2, 4, 5, 3, 6, 4, 6 };
    // Конец ребра
    std::array<int, m> J{ 4, 1, 2, 4, 2, 3, 3, 3, 2, 5, 3, 6, 5 };
    // Длина ребра
    std::array<int, m> C{ 9, 6, 9, 4, 8, 6, 7, 3, 5, 2, 4, 3, 4 };
    // Включенные в связывающее дерево ребра
    std::array<int, n - 1> K{ 0 };
    // Номер подмножества, в которое входит вершина [v]
    std::array<int, n> M{ 0 };
    // Номер первой вершины, входящей в подмножество k
    std::array<int, n> H{ 0 };
    // Следующая вершина, входящая в то же подмножество, что и вершина [v]
    std::array<int, n> L{ 0 };
    // Число вершин в k-м подмножестве
    std::array<int, n> X{ 0 };
};

// Преобразует почти упорядоченное дерево в упорядоченноеэ
// упорядоченное дерево - значение в его вершине не меньше, чем значения в дочерних вершинах
// частично упорядоченное дерево - упорядоченность выполняется для каждой из вершин, но не для корня
void Graph::surface(int root, int max) {
    // root - корень поддерева
    // max - элемент массива с максимальным индексом, который принадлежит дереву, то есть конец дерева
    int child(-1); // большая из вершин поддерева
    // сохранение значения корня поддерева
    int i_r(I[root]), j_r(J[root]), c_r(C[root]);
    // пока мы находимся в пределах поддерева
    while (2 * root <= max) {
        // если левая вершина совпадает с максимальным элементом поддерева
        if (2 * root == max)
            child = 2 * root; // то это нужная вершина
        else
            // выбираем большую вершину. При равенстве выбирается правая
            (C[2 * root] > C[2 * root + 1]) ? (child = 2 * root) : (child = 2 * root + 1);

        // если вершина больше корня
        if (C[child] > c_r) {
            // большая вершина становится корнем
            I[root] = I[child];
            J[root] = J[child];
            C[root] = C[child];
            root = child;
        }
        // в вершине находится больший элемент
        else break;
    }
    // перенос корня всего поддерева на место, где находилась большая вершина
    I[root] = i_r;
    J[root] = j_r;
    C[root] = c_r;
}

void Graph::sort() {
    int last = m - 1; // номер последнего элемента в массиве
    // идем по "уровням" - от нижнего к верхнему
    // на нижнем уровне поддерево - корень + 2 вершины
    // в корне оказывается большее из 3 чисел
    // на верхних уровнях нет необхомости просматривать все многоуровневое поддерево целиком:
    // большие элементы нижних уровней располагаются в вершинах, исходящих из корня
    // в результате получаем упорядоченное дерево
    for (int i(last / 2); i > 0; --i)
        surface(i, last);

    // рассматриваем дерево, корень которого - 0
    // а конец дерева - последний элемент перед упорядоченной областью
    for (int i(last); i > 0; --i) {
        // в результате образуется упорядоченное дерево
        // в вершине упорядоченного дерева находиться больший элемент
        surface(0, i);
        // больший элемент переносится в конец дерева
        // конец дерева теперь принадлежит упорядоченной области
        // дерево становится частично упорядоченным
        std::swap(I[i], I[0]);
        std::swap(J[i], J[0]);
        std::swap(C[i], C[0]);
    }
}

int Graph::find(const int& i) const {
    return M[i];
}

void Graph::unite(const int& mi, const int& mj) {
    // less - номер меньшего подмножества
    int less(-1);
    // larger - номер большего подмножества
    int larger(-1);
    // выбираем меньшее из двух подмножеств
    (X[mi] < X[mj]) ? (less = mi, larger = mj) : (less = mj, larger = mi);

    //обход меньшего подмножества
    int v(H[less]);
    for (v; L[v] != -1; v = L[v])
        M[v] = larger; //перекрашиваем вершины
    M[v] = larger; //перекрашиваем последнюю вершину
    L[v] = H[larger]; //к списку k прицепляем список l
    H[larger] = H[less]; //переносим начало списка
    X[larger] += X[less]; //размер нового подмножества
}

Graph::Graph() {
    sort();
    //Инициализация данных в задаче Объединить-Найти
    for (int v(0); v < n; ++v) {
        H[v] = v;
        L[v] = -1;
        X[v] = 1;
        M[v] = v;
    }
    int w(0); // Указатель на первую свободную позицию в массиве K

    // Просмотр ребер графа по возрастанию длины
    // Заканчиваем просмотр после исчерпания дуг графа
    // и когда полностью сформируется дерево
    for (int e(0); e < m && w < n - 1; ++e) {
        int i(I[e]);
        int j(J[e]);
        int mi = find(i);
        int mj = find(j);
        // Если i и j находятся в разных подмножествах, т.е. не образуется цикл
        if (mi != mj) {
            K[w] = e; // Добавляем ребро k в граф K
            ++w;
            unite(mi, mj);
        }
    }
}

void Graph::print() const {
    std::cout << "   ";
    for (int i(0); i < m; ++i)
        std::cout << std::setw(2) << i << " ";
    std::cout << "\nI: ";
    for (const auto& it : I)
        std::cout << std::setw(2) << it << " ";
    std::cout << "\nJ: ";
    for (const auto& it : J)
        std::cout << std::setw(2) << it << " ";
    std::cout << "\nC: ";
    for (const auto& it : C)
        std::cout << std::setw(2) << it << " ";
    std::cout << "\nK: ";
    for (const auto& it : K)
        std::cout << std::setw(2) << it << " ";
    std::cout << "\n";
}

int main() {
    Graph obj{ Graph() };
    obj.print();
};